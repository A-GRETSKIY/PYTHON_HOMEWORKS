# 1) Реализуйте генераторную функцию, которая будет возвращать по одному
# члену числовой последовательности, закон которой задается с помощью
# пользовательской функции. Кроме этого параметром генераторной функции
# должны быть значение первого члена прогрессии и количество выдаваемых
# членов последовательности (n). Генератор должен остановить свою работу
# или по достижению n — го члена , или при передаче команды на завершение.

def arithmetic_progression(a_0, dx, n):
    return a_0 + n * dx


def geom_progression(b_0, q, n):
    return b_0 * q ** (n - 1)


def get_next_item(start: int | float, step: int | float, n: int, func_tool):
    i = 0
    items = (func_tool(start, step, i) for i in range(n))
    while i < n:
        try:
            yield next(items)
        except:
            break


print(*get_next_item(10, 3, 20, arithmetic_progression))
print(*get_next_item(1, 2, 20, geom_progression))









# 2) Используя функцию замыкания реализуйте такой прием программирования
# как Мемоизация - https://en.wikipedia.org/wiki/Memoization
# Используйте полученный механизм для ускорения функции рекурсивного
# вычисления n — го члена ряда Фибоначчи. Сравните скорость выполнения с
# просто рекурсивным подходом.


# 3) Напишите функцию, которая применит к списку чисел произвольную
# пользовательскую функцию и вернет суммы элементов полученного списка.
